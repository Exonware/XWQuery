/**
 * XWUIItem Component
 * A single item UI element that takes a JSON config and converts it into HTML
 * For multiple items, use XWUIItemGroup
 * 
 * This component accepts exactly ONE JSON item configuration following the schema
 * defined in XWUIItem.schema.json
 * 
 * @schema See XWUIItem.schema.json for the authoritative JSON schema
 */

import { XWUIComponent, type XWUISystemConfig, type XWUIUserConfig } from '../XWUIComponent/XWUIComponent';

// --- TYPE DEFINITIONS ---

export type ItemSize = 'xs' | 's' | 'm' | 'l' | 'xl';
export type Direction = 'ltr' | 'rtl';
export type ContentPartType = 'text' | 'icon' | 'image' | 'progress_bar' | 'user_stack';
export type ItemType = 'card' | 'row' | 'banner' | 'search' | 'chat_bubble';
export type ItemStatus = 'before_start' | 'processing' | 'error' | 'pass';

export interface ContentPart {
    type: ContentPartType;
    value: any;
    style?: string;
    color?: string;
    shape?: 'circle' | 'square';
    // Text overflow options
    textOverflow?: {
        mode?: 'ellipsis' | 'expandable'; // 'ellipsis' = show "...", 'expandable' = show +/- button
        maxLines?: number; // Maximum lines before overflow (default: 1 for ellipsis, 3 for expandable)
        expanded?: boolean; // Initial expanded state (for expandable mode)
    };
}

export interface ItemConfig {
    // Required fields
    uid?: string; // Optional - auto-generated by XWUIComponent if not provided
    id: string;
    primaryContent: ContentPart[];
    
    // Content sections
    avatarContent?: ContentPart[];
    secondaryContent?: ContentPart[];
    tertiaryContent?: ContentPart[];
    primaryContent_other?: ContentPart[];
    secondaryContent_other?: ContentPart[];
    tertiaryContent_other?: ContentPart[];
    
    // Content section visibility (overrides component-level visibility)
    contentVisibility?: {
        avatarContent?: boolean | 'auto';
        primaryContent?: boolean | 'auto';
        primaryContent_other?: boolean | 'auto';
        secondaryContent?: boolean | 'auto';
        secondaryContent_other?: boolean | 'auto';
        tertiaryContent?: boolean | 'auto';
        tertiaryContent_other?: boolean | 'auto';
    };
    
    // Layout and styling
    item_type?: ItemType;
    item_size?: ItemSize;
    item_axis?: 'h' | 'v';
    background_color?: string;
    background_media_paths?: string[];
    status?: ItemStatus;
    
    // States
    itemStates?: {
        isSelected?: boolean;
        isExpanded?: boolean;
        isFavorite?: boolean;
        isArchived?: boolean;
    };
    
    // Actions
    itemActionsSettings?: {
        canSelect?: boolean;
        canDelete?: boolean;
        canAdd?: boolean;
        canEdit?: boolean;
        canDrag?: boolean;
        canClick?: boolean;
        canRightClick?: boolean;
        canArchive?: boolean;
        canSave?: boolean;
        canLoad?: boolean;
        canFav?: boolean;
        canMoreOptions?: boolean;
        canSelectText?: boolean;
    };
    
    // Action visibility (overrides component-level visibility)
    actionVisibility?: {
        checkbox?: boolean | 'auto';
        dragHandle?: boolean | 'auto';
        expandIcon?: boolean | 'auto';
        actions?: boolean | 'auto';
        addButton?: boolean | 'auto';
        delete?: boolean | 'auto';
        edit?: boolean | 'auto';
        archive?: boolean | 'auto';
        save?: boolean | 'auto';
        load?: boolean | 'auto';
        fav?: boolean | 'auto';
        moreOptions?: boolean | 'auto';
    };
    
    // Group-related (for XWUIItemGroup)
    group_type?: 'collapsible_list' | 'inline_grid';
    group_flow?: 'list' | 'table' | 'free' | 'grid';
    group_axis?: 'v' | 'h';
    group_stops?: boolean;
    group_list?: ItemConfig[];
    showWhenCollapsed?: boolean;
    
    // Action metadata
    item_action?: string;
}

// Component-level configuration
export interface XWUIItemConfig {
    // Visibility controls for each content section
    visibility?: {
        dragHandle?: boolean | 'auto';
        expandIcon?: boolean | 'auto';
        avatarContent?: boolean;
        primaryContent?: boolean;
        primaryContent_other?: boolean;
        secondaryContent?: boolean;
        secondaryContent_other?: boolean;
        tertiaryContent?: boolean;
        tertiaryContent_other?: boolean;
        checkbox?: boolean | 'auto';
        actions?: boolean | 'auto';
        addButton?: boolean | 'auto';
    };
    
    // Layout and behavior
    isCollapsed?: boolean;
    highlightedItem?: string | null;
    language?: { [key: string]: string };
    
    // Event handlers
    onItemClick?: (item: ItemConfig, event: MouseEvent) => void;
    onItemRightClick?: (item: ItemConfig, event: MouseEvent) => void;
    onItemAction?: (action: string, item: ItemConfig, event: MouseEvent) => void;
    
    // Console for error logging
    console?: any;
}

// --- ICON MAPPING (SVG Icons) ---

export const ICON_SVGS: { [key: string]: string } = {
    user: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2"/></svg>',
    mail: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></svg>',
    star: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    logout: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>',
    shield: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>',
    folder: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
    file: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>',
    settings: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3m15.364 6.364L16.95 16.95m-9.9-9.9L7.05 7.05M18.364 5.636l-1.414 1.414M7.05 16.95l-1.414 1.414"/></svg>',
    edit: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
    add: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>',
    trash: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>',
    archive: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></svg>',
    more: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>',
    search: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>',
    chevronRight: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>',
    default: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>'
};

export function getIconSVG(iconName?: string): string {
    if (!iconName) return ICON_SVGS.default;
    return ICON_SVGS[iconName.toLowerCase()] || ICON_SVGS.default;
}

// --- CONTENT PART RENDERER ---

export function renderContentPart(part: ContentPart, language?: { [key: string]: string }, canSelectText?: boolean, partIndex?: number): string {
    const textSelectionClass = canSelectText ? 'xwui-item-select-text' : '';
    
    switch (part.type) {
        case 'text':
            let value = typeof part.value === 'string' ? part.value : JSON.stringify(part.value);
            
            // Apply language translation if available
            if (language && language[value]) {
                value = language[value];
            }
            
            const styleClasses = [
                part.style === 'bold' ? 'xwui-item-text-bold' : '',
                part.style === 'subdued' ? 'xwui-item-text-subdued' : '',
                part.style === 'timestamp' ? 'xwui-item-text-timestamp' : ''
            ].filter(Boolean).join(' ');
            
            const colorStyle = part.color ? `color: ${part.color};` : '';
            
            // Handle text overflow
            const overflow = part.textOverflow;
            if (overflow && overflow.mode) {
                const uniqueId = `text-overflow-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${partIndex || 0}`;
                const maxLines = overflow.maxLines || (overflow.mode === 'ellipsis' ? 1 : 3);
                const isExpanded = overflow.expanded === true;
                
                if (overflow.mode === 'ellipsis') {
                    // Ellipsis mode: show "..." when text overflows
                    return `<span class="xwui-item-text ${textSelectionClass} ${styleClasses} xwui-item-text-ellipsis" style="${colorStyle}; --max-lines: ${maxLines}" dir="auto">${escapeHtml(value)}</span>`;
                } else if (overflow.mode === 'expandable') {
                    // Expandable mode: show +/- button
                    const expandButton = `<button class="xwui-item-text-expand-btn" data-text-id="${uniqueId}" aria-label="${isExpanded ? 'Show less' : 'Show more'}">${isExpanded ? '−' : '+'}</button>`;
                    return `<div class="xwui-item-text-expandable-wrapper" data-text-id="${uniqueId}">
                        <span class="xwui-item-text ${textSelectionClass} ${styleClasses} xwui-item-text-expandable ${isExpanded ? 'xwui-item-text-expanded' : ''}" style="${colorStyle}; --max-lines: ${maxLines}" dir="auto">${escapeHtml(value)}</span>
                        ${expandButton}
                    </div>`;
                }
            }
            
            return `<span class="xwui-item-text ${textSelectionClass} ${styleClasses}" style="${colorStyle}" dir="auto">${escapeHtml(value)}</span>`;
            
        case 'icon':
            const iconSVG = getIconSVG(part.value);
            const iconColor = part.color ? `color: ${part.color};` : '';
            return `<span class="xwui-item-icon" style="${iconColor}">${iconSVG}</span>`;
            
        case 'image':
            const shapeClass = part.shape === 'circle' ? 'xwui-item-image-circle' : 'xwui-item-image-square';
            return `<img src="${escapeHtml(part.value)}" class="xwui-item-image ${shapeClass} ${textSelectionClass}" alt="" />`;
            
        case 'progress_bar':
            const progress = typeof part.value === 'number' ? part.value : 0;
            return `<div class="xwui-item-progress-bar"><div class="xwui-item-progress-fill" style="width: ${progress}%"></div></div>`;
            
        case 'user_stack':
            // Render multiple user avatars
            const users = Array.isArray(part.value) ? part.value : [];
            const userAvatars = users.slice(0, 3).map((user: any, idx: number) => {
                const src = typeof user === 'string' ? user : user.avatar || user;
                const offset = idx * -8;
                return `<img src="${escapeHtml(src)}" class="xwui-item-user-avatar" data-user-index="${idx}" style="z-index: ${10 - idx};" alt="" />`;
            }).join('');
            return `<div class="xwui-item-user-stack">${userAvatars}</div>`;
            
        default:
            return `<div class="${textSelectionClass}">${escapeHtml(JSON.stringify(part.value))}</div>`;
    }
}

export function renderContentBlock(content?: ContentPart[], language?: { [key: string]: string }, canSelectText?: boolean, direction: Direction = 'ltr'): string {
    if (!content || content.length === 0) return '';
    
    // DO NOT reverse the order of parts inside content-block
    // Keep the same order for both LTR and RTL - let CSS and browser handle RTL naturally
    const parts = content.map((part, index) => renderContentPart(part, language, canSelectText, index)).join('');
    return `<div class="xwui-item-content-block" dir="${direction}">${parts}</div>`;
}

// --- HELPER FUNCTIONS ---

function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function getSizeClasses(size?: ItemSize): string {
    const sizeMap: Record<ItemSize, string> = {
        xs: 'xwui-item-size-xs',
        s: 'xwui-item-size-s',
        m: 'xwui-item-size-m',
        l: 'xwui-item-size-l',
        xl: 'xwui-item-size-xl'
    };
    return sizeMap[size || 's'] || sizeMap.s;
}

// --- MAIN XWUIItem CLASS (Single Item Only) ---

export class XWUIItem extends XWUIComponent<ItemConfig, XWUIItemConfig> {
    private itemElement: HTMLElement | null = null;

    /**
     * Creates an XWUIItem instance for a SINGLE item
     * @param container - HTML element to render the item into
     * @param data - Item data configuration
     * @param conf_comp - Component-level configuration
     * @param conf_sys - System-level configuration
     * @param conf_usr - User-level configuration
     */
    constructor(
        container: HTMLElement,
        data: ItemConfig,
        conf_comp?: XWUIItemConfig,
        conf_sys?: XWUISystemConfig,
        conf_usr?: XWUIUserConfig
    ) {
        super(container, data, conf_comp, conf_sys, conf_usr);
        
        // Ensure data has uid from base class
        if (!this.data.uid) {
            this.data.uid = this.uid;
        }
        
        // Validate that we have exactly one item with required fields
        this.validateItem(this.data);
        
        this.render();
    }

    /**
     * Create component-specific config
     */
    protected createConfig(
        conf_comp?: XWUIItemConfig,
        conf_usr?: XWUIUserConfig,
        conf_sys?: XWUISystemConfig
    ): XWUIItemConfig {
        return {
            visibility: {
                dragHandle: conf_comp?.visibility?.dragHandle ?? 'auto',
                expandIcon: conf_comp?.visibility?.expandIcon ?? 'auto',
                avatarContent: conf_comp?.visibility?.avatarContent ?? true,
                primaryContent: conf_comp?.visibility?.primaryContent ?? true,
                primaryContent_other: conf_comp?.visibility?.primaryContent_other ?? true,
                secondaryContent: conf_comp?.visibility?.secondaryContent ?? true,
                secondaryContent_other: conf_comp?.visibility?.secondaryContent_other ?? true,
                tertiaryContent: conf_comp?.visibility?.tertiaryContent ?? true,
                tertiaryContent_other: conf_comp?.visibility?.tertiaryContent_other ?? true,
                checkbox: conf_comp?.visibility?.checkbox ?? 'auto',
                actions: conf_comp?.visibility?.actions ?? 'auto',
                addButton: conf_comp?.visibility?.addButton ?? 'auto'
            },
            isCollapsed: conf_comp?.isCollapsed ?? false,
            highlightedItem: conf_comp?.highlightedItem ?? null,
            language: conf_comp?.language,
            onItemClick: conf_comp?.onItemClick,
            onItemRightClick: conf_comp?.onItemRightClick,
            onItemAction: conf_comp?.onItemAction,
            console: conf_comp?.console
        };
    }

    /**
     * Validates that the item follows the schema requirements
     * Ensures required fields are present: uid (auto-generated if missing), id, primaryContent
     */
    private validateItem(item: ItemConfig): void {
        try {
            // uid is auto-generated by base class, just ensure it's a string
            if (!item.uid || typeof item.uid !== 'string') {
                // Use the base class uid if item doesn't have one
                item.uid = this.uid;
            }
            if (!item.id || typeof item.id !== 'string') {
                const error = new Error('XWUIItem: item.id is required and must be a string');
                this.logError(error, item);
                throw error;
            }
            if (!item.primaryContent || !Array.isArray(item.primaryContent) || item.primaryContent.length === 0) {
                const error = new Error('XWUIItem: item.primaryContent is required and must be a non-empty array');
                this.logError(error, item);
                throw error;
            }
            
            // Validate primaryContent items
            item.primaryContent.forEach((part, index) => {
                if (!part.type || !part.hasOwnProperty('value')) {
                    const error = new Error(`XWUIItem: item.primaryContent[${index}] must have 'type' and 'value' properties`);
                    this.logError(error, item, { part, index });
                    throw error;
                }
            });
        } catch (error) {
            // Re-throw after logging
            throw error;
        }
    }

    /**
     * Logs errors to the console if available
     */
    private logError(error: Error, item: ItemConfig, context?: any): void {
        if (this.config.console && typeof this.config.console.error === 'function') {
            const source = `XWUIItem[${item.id || item.uid || 'unknown'}]`;
            const message = error.message;
            const stack = error.stack;
            const data = {
                item: {
                    uid: item.uid,
                    id: item.id,
                    item_type: item.item_type,
                    item_size: item.item_size
                },
                ...(context ? { context } : {})
            };
            this.config.console.error(message, source, data, stack);
        }
    }

    /**
     * Check if a content section should be visible
     */
    private shouldShowContent(section: 'avatarContent' | 'primaryContent' | 'primaryContent_other' | 'secondaryContent' | 'secondaryContent_other' | 'tertiaryContent' | 'tertiaryContent_other', item: ItemConfig): boolean {
        // Check item-level visibility first
        const itemVisibility = item.contentVisibility?.[section];
        if (itemVisibility !== undefined) {
            if (itemVisibility === 'auto') {
                // Auto logic: show if content exists
                return !!item[section];
            }
            return itemVisibility;
        }
        
        // Check component-level visibility
        const compVisibility = this.config.visibility?.[section];
        if (compVisibility !== undefined) {
            if (typeof compVisibility === 'string' && compVisibility === 'auto') {
                return !!item[section];
            }
            if (typeof compVisibility === 'boolean') {
                return compVisibility;
            }
        }
        
        // Default: show if content exists
        return !!item[section];
    }

    /**
     * Check if an action should be visible
     */
    private shouldShowAction(action: 'checkbox' | 'dragHandle' | 'expandIcon' | 'actions' | 'addButton' | 'delete' | 'edit' | 'archive' | 'save' | 'load' | 'fav' | 'moreOptions', item: ItemConfig): boolean {
        // Check item-level visibility first
        const itemVisibility = item.actionVisibility?.[action];
        if (itemVisibility !== undefined) {
            if (itemVisibility === 'auto') {
                // Auto logic based on action type
                switch (action) {
                    case 'checkbox':
                        return item.itemActionsSettings?.canSelect === true;
                    case 'dragHandle':
                        return item.itemActionsSettings?.canDrag === true;
                    case 'expandIcon':
                        return !!item.group_list;
                    case 'addButton':
                        return item.itemActionsSettings?.canAdd === true;
                    case 'actions':
                        // Show if any action is enabled
                        return Object.keys(item.itemActionsSettings || {}).some(
                            key => key.startsWith('can') && 
                            !['canClick', 'canRightClick', 'canSelectText', 'canSelect'].includes(key) &&
                            item.itemActionsSettings![key as keyof typeof item.itemActionsSettings]
                        );
                    default:
                        // For individual actions, check if the corresponding can* is true
                        const canKey = `can${action.charAt(0).toUpperCase() + action.slice(1)}` as keyof typeof item.itemActionsSettings;
                        return item.itemActionsSettings?.[canKey] === true;
                }
            }
            return itemVisibility;
        }
        
        // Check component-level visibility (only for actions that exist in config)
        const compVisibility = (action === 'checkbox' || action === 'dragHandle' || action === 'expandIcon' || action === 'actions' || action === 'addButton')
            ? this.config.visibility?.[action]
            : undefined;
        if (compVisibility !== undefined) {
            if (compVisibility === 'auto') {
                // Same auto logic
                switch (action) {
                    case 'checkbox':
                        return item.itemActionsSettings?.canSelect === true;
                    case 'dragHandle':
                        return item.itemActionsSettings?.canDrag === true;
                    case 'expandIcon':
                        return !!item.group_list;
                    case 'addButton':
                        return item.itemActionsSettings?.canAdd === true;
                    case 'actions':
                        return Object.keys(item.itemActionsSettings || {}).some(
                            key => key.startsWith('can') && 
                            !['canClick', 'canRightClick', 'canSelectText', 'canSelect'].includes(key) &&
                            item.itemActionsSettings![key as keyof typeof item.itemActionsSettings]
                        );
                    default:
                        const canKey = `can${action.charAt(0).toUpperCase() + action.slice(1)}` as keyof typeof item.itemActionsSettings;
                        return item.itemActionsSettings?.[canKey] === true;
                }
            }
            return compVisibility;
        }
        
        // Default: use auto logic
        switch (action) {
            case 'checkbox':
                return item.itemActionsSettings?.canSelect === true;
            case 'dragHandle':
                return item.itemActionsSettings?.canDrag === true;
            case 'expandIcon':
                return !!item.group_list;
            case 'addButton':
                return item.itemActionsSettings?.canAdd === true;
            case 'actions':
                return Object.keys(item.itemActionsSettings || {}).some(
                    key => key.startsWith('can') && 
                    !['canClick', 'canRightClick', 'canSelectText', 'canSelect'].includes(key) &&
                    item.itemActionsSettings![key as keyof typeof item.itemActionsSettings]
                );
            default:
                const canKey = `can${action.charAt(0).toUpperCase() + action.slice(1)}` as keyof typeof item.itemActionsSettings;
                return item.itemActionsSettings?.[canKey] === true;
        }
    }

    private render(): void {
        const { language, isCollapsed = false, highlightedItem, onItemClick, onItemRightClick, onItemAction } = this.config;
        const item = this.data;
        const direction = this.getDirection();
        
        // Clear container
        this.container.innerHTML = '';
        
        // Create item element
        this.itemElement = document.createElement('div');
        this.itemElement.className = `xwui-item ${getSizeClasses(item.item_size)} ${item.item_type || 'row'}`;
        this.itemElement.setAttribute('data-uid', item.uid);
        this.itemElement.setAttribute('data-id', item.id);
        this.itemElement.setAttribute('dir', direction);
        
        // Set background color based on status (status takes precedence over background_color)
        if (item.status) {
            this.itemElement.classList.add(`xwui-item-status-${item.status}`);
        } else if (item.background_color) {
            // Only use background_color if no status is set
            this.itemElement.style.backgroundColor = item.background_color;
        }
        
        // Add highlighted class if this item is highlighted
        if (highlightedItem === item.uid) {
            this.itemElement.classList.add('xwui-item-highlighted');
        }
        
        // Add interactive classes
        const canClick = item.itemActionsSettings?.canClick !== false;
        if (canClick) {
            this.itemElement.classList.add('xwui-item-clickable');
            if (onItemClick) {
                this.itemElement.addEventListener('click', (e) => {
                    // If item has group_list, handle expand/collapse via action
                    if (item.group_list && onItemAction) {
                        onItemAction('toggle_expand', item, e);
                    } else {
                        // Call onItemClick if provided, regardless of item_action
                        onItemClick(item, e);
                    }
                });
            }
        }
        
        // Add right-click handler
        if (item.itemActionsSettings?.canRightClick && onItemRightClick) {
            this.itemElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                onItemRightClick(item, e);
            });
        }
        
        // Render content based on item type
        if (item.item_type === 'search') {
            this.renderSearchItem(item, language, direction);
        } else if (isCollapsed) {
            this.renderCollapsedItem(item, language);
        } else {
            this.renderFullItem(item, language, direction);
        }
        
        this.container.appendChild(this.itemElement);
        
        // Attach expand/collapse handlers for expandable text
        this.attachTextExpandHandlers();
    }
    
    /**
     * Attach event handlers for expandable text overflow buttons
     */
    private attachTextExpandHandlers(): void {
        if (!this.itemElement) return;
        
        const expandButtons = this.itemElement.querySelectorAll('.xwui-item-text-expand-btn');
        expandButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const textId = button.getAttribute('data-text-id');
                if (!textId) return;
                
                const wrapper = this.itemElement?.querySelector(`[data-text-id="${textId}"]`)?.closest('.xwui-item-text-expandable-wrapper');
                if (!wrapper) return;
                
                const textElement = wrapper.querySelector('.xwui-item-text-expandable');
                if (!textElement) return;
                
                const isExpanded = textElement.classList.contains('xwui-item-text-expanded');
                
                if (isExpanded) {
                    textElement.classList.remove('xwui-item-text-expanded');
                    button.textContent = '+';
                    button.setAttribute('aria-label', 'Show more');
                } else {
                    textElement.classList.add('xwui-item-text-expanded');
                    button.textContent = '−';
                    button.setAttribute('aria-label', 'Show less');
                }
            });
        });
    }

    private renderSearchItem(item: ItemConfig, language?: { [key: string]: string }, direction: Direction = 'ltr'): void {
        if (!this.itemElement) return;
        
        const placeholder = item.primaryContent[0]?.value || 'Search...';
        const translatedPlaceholder = language && language[placeholder] ? language[placeholder] : placeholder;
        const searchIcon = getIconSVG('search');
        const inputClass = direction === 'ltr' ? 'xwui-item-search-input-ltr' : 'xwui-item-search-input-rtl';
        const iconClass = direction === 'ltr' ? 'xwui-item-search-icon-ltr' : 'xwui-item-search-icon-rtl';
        
        this.itemElement.innerHTML = `
            <div class="xwui-item-search-container">
                <div class="xwui-item-search-icon ${iconClass}">${searchIcon}</div>
                <input type="text" class="xwui-item-search-input ${inputClass}" placeholder="${escapeHtml(translatedPlaceholder)}" />
            </div>
        `;
    }

    private renderCollapsedItem(item: ItemConfig, language?: { [key: string]: string }): void {
        if (!this.itemElement) return;
        
        const canSelectText = item.itemActionsSettings?.canSelectText;
        const avatarContent = this.shouldShowContent('avatarContent', item) 
            ? renderContentBlock(item.avatarContent, language, canSelectText)
            : '';
        
        this.itemElement.innerHTML = `
            <div class="xwui-item-collapsed">
                ${avatarContent}
            </div>
        `;
    }

    private renderFullItem(item: ItemConfig, language?: { [key: string]: string }, direction: Direction = 'ltr'): void {
        if (!this.itemElement) return;
        
        const canSelectText = item.itemActionsSettings?.canSelectText;
        const size = item.item_size || 's';
        
        if (size === 'xl') {
            this.renderXLargeItem(item, language, canSelectText, direction);
        } else {
            this.renderStandardItem(item, language, canSelectText, direction);
        }
    }

    private renderXLargeItem(item: ItemConfig, language?: { [key: string]: string }, canSelectText?: boolean, direction: Direction = 'ltr'): void {
        if (!this.itemElement) return;
        
        const checkbox = this.shouldShowAction('checkbox', item) && item.itemActionsSettings?.canSelect
            ? `<input type="checkbox" class="xwui-item-checkbox" ${item.itemStates?.isSelected ? 'checked' : ''} readonly />`
            : '';
        
        const avatarContent = this.shouldShowContent('avatarContent', item)
            ? renderContentBlock(item.avatarContent, language, canSelectText, direction)
            : '';
        
        const primaryContent = this.shouldShowContent('primaryContent', item)
            ? renderContentBlock(item.primaryContent, language, canSelectText, direction)
            : '';
        const primaryContentOther = this.shouldShowContent('primaryContent_other', item)
            ? renderContentBlock(item.primaryContent_other, language, canSelectText, direction)
            : '';
        const secondaryContent = this.shouldShowContent('secondaryContent', item)
            ? renderContentBlock(item.secondaryContent, language, canSelectText, direction)
            : '';
        const tertiaryContent = this.shouldShowContent('tertiaryContent', item)
            ? renderContentBlock(item.tertiaryContent, language, canSelectText, direction)
            : '';
        const tertiaryContentOther = this.shouldShowContent('tertiaryContent_other', item)
            ? renderContentBlock(item.tertiaryContent_other, language, canSelectText, direction)
            : '';
        const secondaryContentOther = this.shouldShowContent('secondaryContent_other', item)
            ? renderContentBlock(item.secondaryContent_other, language, canSelectText, direction)
            : '';
        
        const actions = this.shouldShowAction('actions', item) ? this.renderActionButtons(item) : '';
        
        const xlLayoutDiv = document.createElement('div');
        xlLayoutDiv.className = 'xwui-item-xl-layout';
        xlLayoutDiv.setAttribute('dir', direction);
        
        // Avatar wrapper for positioning outside the bubble
        const avatarWrapper = avatarContent ? document.createElement('div') : null;
        if (avatarWrapper) {
            avatarWrapper.className = 'xwui-item-xl-avatar-wrapper';
            avatarWrapper.setAttribute('dir', direction);
            avatarWrapper.innerHTML = avatarContent;
        }
        
        const xlContentDiv = document.createElement('div');
        xlContentDiv.className = 'xwui-item-xl-content';
        xlContentDiv.setAttribute('dir', direction);
        
        const xlHeaderDiv = document.createElement('div');
        xlHeaderDiv.className = 'xwui-item-xl-header';
        xlHeaderDiv.setAttribute('dir', direction);
        
        const xlHeaderOtherDiv = document.createElement('div');
        xlHeaderOtherDiv.className = 'xwui-item-xl-header-other';
        xlHeaderOtherDiv.setAttribute('dir', direction);
        
        // For RTL, reverse the DOM order of header elements
        if (direction === 'rtl') {
            // RTL order: [actions, primaryContentOther] | primaryContent
            if (actions) xlHeaderOtherDiv.insertAdjacentHTML('beforeend', actions);
            if (primaryContentOther) xlHeaderOtherDiv.insertAdjacentHTML('beforeend', primaryContentOther);
            xlHeaderDiv.appendChild(xlHeaderOtherDiv);
            if (primaryContent) xlHeaderDiv.insertAdjacentHTML('afterbegin', primaryContent);
        } else {
            // LTR order: primaryContent | [primaryContentOther, actions]
            if (primaryContent) xlHeaderDiv.insertAdjacentHTML('beforeend', primaryContent);
            if (primaryContentOther) xlHeaderOtherDiv.insertAdjacentHTML('beforeend', primaryContentOther);
            if (actions) xlHeaderOtherDiv.insertAdjacentHTML('beforeend', actions);
            xlHeaderDiv.appendChild(xlHeaderOtherDiv);
        }
        
        xlContentDiv.appendChild(xlHeaderDiv);
        if (secondaryContent) xlContentDiv.insertAdjacentHTML('beforeend', secondaryContent);
        if (tertiaryContent) xlContentDiv.insertAdjacentHTML('beforeend', tertiaryContent);
        if (tertiaryContentOther) xlContentDiv.insertAdjacentHTML('beforeend', tertiaryContentOther);
        
        // Reaction wrapper for positioning outside the bubble (below)
        const reactionWrapper = secondaryContentOther ? document.createElement('div') : null;
        if (reactionWrapper) {
            reactionWrapper.className = 'xwui-item-xl-reaction-wrapper';
            reactionWrapper.setAttribute('dir', direction);
            reactionWrapper.innerHTML = secondaryContentOther;
        }
        
        // Content wrapper that contains both bubble and reaction
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'xwui-item-xl-content-wrapper';
        contentWrapper.setAttribute('dir', direction);
        contentWrapper.appendChild(xlContentDiv);
        if (reactionWrapper) contentWrapper.appendChild(reactionWrapper);
        
        // Build layout with RTL-specific avatar positioning
        if (checkbox) xlLayoutDiv.insertAdjacentHTML('beforeend', checkbox);
        if (direction === 'rtl') {
            // RTL order: checkbox | content-wrapper | avatar
            xlLayoutDiv.appendChild(contentWrapper);
            if (avatarWrapper) xlLayoutDiv.appendChild(avatarWrapper);
        } else {
            // LTR order: checkbox | avatar | content-wrapper
            if (avatarWrapper) xlLayoutDiv.appendChild(avatarWrapper);
            xlLayoutDiv.appendChild(contentWrapper);
        }
        
        this.itemElement.innerHTML = '';
        this.itemElement.appendChild(xlLayoutDiv);
    }

    private renderStandardItem(item: ItemConfig, language?: { [key: string]: string }, canSelectText?: boolean, direction: Direction = 'ltr'): void {
        if (!this.itemElement) return;
        
        const dragHandle = this.shouldShowAction('dragHandle', item) && item.itemActionsSettings?.canDrag
            ? '<div class="xwui-item-drag-handle">' + getIconSVG('more') + '</div>'
            : '';
        
        // Show expand icon if item has group_list
        const expandIcon = this.shouldShowAction('expandIcon', item) && item.group_list
            ? `<div class="xwui-item-expand-icon ${item.itemStates?.isExpanded ? 'xwui-item-expanded' : ''}">${getIconSVG('chevronRight')}</div>`
            : '';
        
        const avatarContent = this.shouldShowContent('avatarContent', item)
            ? renderContentBlock(item.avatarContent, language, canSelectText, direction)
            : '';
        const primaryContent = this.shouldShowContent('primaryContent', item)
            ? renderContentBlock(item.primaryContent, language, canSelectText, direction)
            : '';
        
        const addButton = this.shouldShowAction('addButton', item) && item.itemActionsSettings?.canAdd && this.config.onItemAction
            ? `<button class="xwui-item-add-button" data-action="add_child_item">${getIconSVG('add')}</button>`
            : '';
        
        const layoutDiv = document.createElement('div');
        layoutDiv.className = 'xwui-item-standard-layout';
        layoutDiv.setAttribute('dir', direction);
        
        // For RTL, reverse the DOM order so icon appears on right side
        if (direction === 'rtl') {
            // RTL DOM order: addButton | primaryContent | avatarContent | expandIcon | dragHandle
            // With flex-direction: row-reverse, visual order: dragHandle | expandIcon | avatarContent | primaryContent | addButton
            // This puts avatarContent (icon) on the RIGHT side of primaryContent (text)
            if (addButton) layoutDiv.insertAdjacentHTML('beforeend', addButton);
            const primaryDiv = document.createElement('div');
            primaryDiv.className = 'xwui-item-primary-content';
            primaryDiv.setAttribute('dir', direction);
            primaryDiv.innerHTML = primaryContent;
            layoutDiv.appendChild(primaryDiv);
            if (avatarContent) layoutDiv.insertAdjacentHTML('beforeend', avatarContent);
            if (expandIcon) layoutDiv.insertAdjacentHTML('beforeend', expandIcon);
            if (dragHandle) layoutDiv.insertAdjacentHTML('beforeend', dragHandle);
        } else {
            // LTR order: dragHandle | expandIcon | avatarContent | primaryContent | addButton
            if (dragHandle) layoutDiv.insertAdjacentHTML('beforeend', dragHandle);
            if (expandIcon) layoutDiv.insertAdjacentHTML('beforeend', expandIcon);
            if (avatarContent) layoutDiv.insertAdjacentHTML('beforeend', avatarContent);
            const primaryDiv = document.createElement('div');
            primaryDiv.className = 'xwui-item-primary-content';
            primaryDiv.setAttribute('dir', direction);
            primaryDiv.innerHTML = primaryContent;
            layoutDiv.appendChild(primaryDiv);
            if (addButton) layoutDiv.insertAdjacentHTML('beforeend', addButton);
        }
        
        this.itemElement.innerHTML = '';
        this.itemElement.appendChild(layoutDiv);
        
        // Attach add button handler
        if (addButton && this.config.onItemAction) {
            const addBtn = this.itemElement.querySelector('.xwui-item-add-button');
            if (addBtn) {
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.config.onItemAction!('add_child_item', item, e as MouseEvent);
                });
            }
        }
    }

    private renderActionButtons(item: ItemConfig): string {
        if (!item.itemActionsSettings) return '';
        
        const actions = Object.keys(item.itemActionsSettings)
            .filter(key => {
                if (!key.startsWith('can')) return false;
                if (['canClick', 'canRightClick', 'canSelectText', 'canSelect'].includes(key)) return false;
                
                // Check visibility for individual actions
                const actionName = key.substring(3).toLowerCase() as 'delete' | 'edit' | 'archive' | 'save' | 'load' | 'fav' | 'moreOptions';
                if (!this.shouldShowAction(actionName, item)) return false;
                
                return item.itemActionsSettings![key as keyof typeof item.itemActionsSettings];
            })
            .slice(0, 3);
        
        if (actions.length === 0) return '';
        
        const buttons = actions.map(actionKey => {
            const iconName = actionKey.substring(3).toLowerCase();
            const icon = getIconSVG(iconName);
            return `<button class="xwui-item-action-button" data-action="${actionKey}">${icon}</button>`;
        }).join('');
        
        const moreButton = Object.keys(item.itemActionsSettings).filter(key => 
            key.startsWith('can') && 
            !['canClick', 'canRightClick', 'canSelectText', 'canSelect'].includes(key) &&
            item.itemActionsSettings![key as keyof typeof item.itemActionsSettings]
        ).length > 3
            ? `<button class="xwui-item-action-button xwui-item-more-button" data-action="more">${getIconSVG('more')}</button>`
            : '';
        
        return `<div class="xwui-item-actions">${buttons}${moreButton}</div>`;
    }

    public updateConfig(newConfig: Partial<XWUIItemConfig>): void {
        // Update config by merging with new values
        Object.assign(this.config, newConfig);
        this.render();
    }
    
    /**
     * Update item data and re-render
     */
    public updateData(newData: Partial<ItemConfig>): void {
        // Merge new data with existing data
        this.data = { ...this.data, ...newData } as ItemConfig;
        
        // Ensure uid exists
        if (!this.data.uid) {
            this.data.uid = this.uid;
        }
        
        // Validate and re-render
        this.validateItem(this.data);
        this.render();
    }

    public getElement(): HTMLElement | null {
        return this.itemElement;
    }

    public destroy(): void {
        if (this.itemElement) {
            this.itemElement.remove();
            this.itemElement = null;
        }
    }
}

// Set component name at class definition (before minification) - survives build tools
(XWUIItem as any).componentName = 'XWUIItem';