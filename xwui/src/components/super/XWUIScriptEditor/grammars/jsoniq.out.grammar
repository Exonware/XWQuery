# jsoniq.out.grammar
# JSONiq Output Grammar - Template for generating JSONiq from AST
# Company: eXonware.com
# Version: 1.0

@module = {{#if prolog}}{{prolog}}
{{/if}}{{expression}}

@prolog = {{#each declarations}}{{value}}
{{/each}}

@namespace_decl = declare namespace {{name}} = {{uri}}

@variable_decl = declare variable ${{name}} := {{value}}

@expression = {{value}}

@flwor_expr = {{#each clauses}}{{value}}
{{/each}}{{#if where}}{{where}}
{{/if}}{{#if order}}{{order}}
{{/if}}return {{return}}

@for_clause = for ${{var}} in {{source}}

@let_clause = let ${{var}} := {{value}}

@where_clause = where {{expression}}

@order_clause = order by {{#each specs}}{{value}}{{#if !@last}}, {{/if}}{{/each}}

@order_spec = {{expression}}{{#if direction}} {{direction}}{{/if}}

@or_expr = {{#each terms}}{{value}}{{#if !@last}} or {{/if}}{{/each}}

@and_expr = {{#each terms}}{{value}}{{#if !@last}} and {{/if}}{{/each}}

@comparison = {{left}}{{#if op}} {{op}} {{right}}{{else}}{{#if range}} to {{end}}{{/if}}{{/if}}

@compare_op = {{value}}

@range_expr = {{start}}{{#if end}} to {{end}}{{/if}}

@additive = {{#each terms}}{{value}}{{#if !@last}} {{operator}} {{/if}}{{/each}}

@multiplicative = {{#each terms}}{{value}}{{#if !@last}} {{operator}} {{/if}}{{/each}}

@unary = {{#if operator}}{{operator}} {{/if}}{{value}}

@postfix_expr = {{primary}}{{#each postfixes}}{{value}}{{/each}}

@postfix = {{value}}

@predicate = [{{expression}}]

@primary_expr = {{value}}

@var_ref = ${{name}}

@function_call = {{name}}({{#if args}}{{args}}{{/if}})

@arg_list = {{#each args}}{{value}}{{#if !@last}}, {{/if}}{{/each}}

@array_constructor = [{{#each items}}{{value}}{{#if !@last}}, {{/if}}{{/each}}]

@object_constructor = {{{#each pairs}}{{key}}: {{value}}{{#if !@last}}, {{/if}}{{/each}}}

@object_pair = {{key}}: {{value}}

@literal = {{value}}

@indent = 2
@pretty = true
